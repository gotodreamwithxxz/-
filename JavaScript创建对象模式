创建对象：
  1.工厂模式，抽象了创建具体对象的过程（解决了多个相似对象的问题，但没有解决对象识别的问题）
  2.构造函数模式，对象具有constructor属性，指向构造名。问题是每个对象的方法都要在函数内部重新创建一遍；若把对象方法放在外面使用，则对象用多个方法就要
定义多个全局函数，这样自定义的引用类型就毫无封装性可言！ so 出现了原型模式
  3.原型（prototype）模式，解决让所有对象共享它所包含的属性和方法。理解ECMAScript中的原型对象
    .给对象实例添加一个属性时，这个属性会屏蔽原型对象中保存的同名属性。若用delete操作符删除这个属性，则会恢复原型中的属性值。
    .hasOwnProperty()对象的方法，检测访问的是实例属性则返回true，原型属性则为false
    .hasPrptotypeProperty(对象名，属性名)，和hasOwnProperty()相反
    .in操作符，不管是实例属性还是原型属性都返回true，不存在为false
    说了这么多，它有什么问题呢？ 对象的引用类型的值由所有实例共享，不能和基本值属性值一样隐藏------
  4.组合使用构造函数模型和原型模型
    这样每个实例都会有自己的实例属性的副本，还可以同时共享对方法的引用**
  5.动态原型模式
  6.寄生构造函数模式
  7.稳妥构造函数模式
    所谓稳妥，即是没有公共属性
    
